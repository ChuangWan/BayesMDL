{
    "collab_server" : "",
    "contents" : "########################################################################\n######     Calculating marginal likelihood for a given eta       #######\n########################################################################\n###### AR(p); monthly data; no trend; can handle metadata\n\n###### Inputs:\n## X: a vector of length N. \n##    For monthly data, no need to pre-processed to zero mean.\n## month: a vector of length N. Take value in {1, 2, ..., 12}.\n##\t\tFor annual data, always equal 1.\n## eta: changepoint configuration. \n##      Length is N, first p elemenet are always 0.\n## meta: a vector of 0-1 indicators. \n##      Length is N, first p elemenet are always 0.\n## p: AR(p)\n## fit: 'marlik' marginal likelihood, or 'lik' likelihood.\n##      Note, the 'lik' option already included the two-part mdl of mu.\n## penalty: 'bmdl' Beta-Binomial prior, 'uniform', 'mdl', 'BIC'\n## nu: default value 5\n## a: default value 1\n## b1: for non-metadata, dafault value 239 (for monthly data)\n## b2: for metadata, dafault value 47 (for monthly data)\n## period = 12 (for monthly data), or 1 (for annual data)\n\n###### Outputs:\n## mdl: Bayesian mdl score for model eta (i.e., lpost)\n## mu: conditional posterior mean of mu (Note: the length of mu is m)\n## s: EB estimators to seasonalities (Note: the length of s is 12)\n## sigmasq: EB estimator\n## phi: Yule-Walker estimator\n########################################################################\n\nbmdl.eta = function(X, month, eta, meta, p, fit, penalty, nu, a, b1, b2, period){\n  \n  m = sum(eta); N = length(X);\n  \n  ## design matrix for seasonality\n  A = matrix(as.numeric(matrix(month, ncol = period, nrow = N) == matrix(1:period, ncol = period, nrow = N, byrow = TRUE)), ncol = period);\n  ## design matrix for regime means\n  D = matrix(as.numeric(matrix(rep(cumsum(eta) + 1, m + 1), ncol = m + 1) == matrix(rep(1:(m + 1), N), ncol = m + 1, byrow = TRUE)), ncol = m + 1);\n  D = as.matrix(D[, -1]);\n  seg.lengths = apply(D, 2, sum);\n  \n  #### compute the Yule-Walker estimate of phi ####\n  ## linear model residuals\n  Y = lm(X ~ cbind(A, D) - 1)$res;\n  \n  ## if AR, not independent, compute phi\n  phi = NULL;\n  if(p > 0){\n    gamma = rep(NA, p + 1); ## gamma_hat of lag h: h = 0, 1, ..., p\n    for(h in 0:p){\n  \t  gamma[h + 1] = sum(c(Y, rep(0, h)) * c(rep(0, h), Y)) / N;\n    }  \n    phi = solve(matrix(gamma[abs(outer(1:p, 1:p, '-')) + 1], nrow = p), gamma[-1]);\n  }  \n  \n  \n  #### compute Ahat, Xhat, and Dhat\n  Ahat = as.matrix(A[(p + 1):N, ]);\n  Xhat = X[(p + 1):N];\n  if(m > 0)\n    Dhat = as.matrix(D[(p + 1):N, ]);\n  if(p > 0){\n  \tfor(h in 1:p){\n  \t  Ahat = as.matrix(Ahat - phi[h] * A[(p + 1 - h):(N - h), ]);\n  \t  Xhat = Xhat - phi[h] * X[(p + 1 - h):(N - h)];\n  \t  if(m > 0)\n  \t    Dhat = as.matrix(Dhat - phi[h] * D[(p + 1 - h):(N - h), ]);\n  \t}\n  }\n    \n  ## if not the null model\n  if(m > 0){ \n\n    #### compute EB estimate of sigmasq and conditional posterior mean of mu\n    tmp = svd(Dhat);  \n    UtX = t(tmp$u) %*% Xhat;\n    UtA = t(tmp$u) %*% Ahat;\n    if(fit == 'marlik')\n      d = tmp$d^2 / (tmp$d^2 + 1 / nu);\n    if(fit == 'lik')\n      d = rep(1, m);\n      \n    if(m > 1){\n      AtBA = t(Ahat) %*% Ahat - t(UtA) %*% diag(d) %*% UtA;\n    }\n   if(m == 1){\n      AtBA = t(Ahat) %*% Ahat - t(UtA) %*% (d * UtA);   \n    }\n    AtBX = t(Ahat) %*% Xhat - t(UtA) %*% (d * UtX); \n    XtBX = sum(Xhat^2) - sum(UtX^2 * d);\n\n    s = solve(AtBA, AtBX);\n  \n    if(m > 1){\n  \t  mu = tmp$v %*% diag(tmp$d / (tmp$d^2 + 1 / nu)) %*% (UtX - UtA %*% s);\n    }\n    if(m == 1){\n  \t  mu = tmp$v * (tmp$d / (tmp$d^2 + 1 / nu)) * (UtX - UtA %*% s);\n    }\n    \n    sigmasq = c((XtBX - t(AtBX) %*% s) / (N - p));\n    \n    ## conditional posterior covariance of mu: sigmasq * inv(Dhat' Dhat + I / nu)\n    cov.mu = solve(t(Dhat) %*% Dhat + diag(m) / nu) * sigmasq;\n    \n    if(fit == 'marlik')\n      mdl.data = (N - p) / 2 * log(sigmasq) + m / 2 * log(nu) + sum(log(tmp$d^2 + 1 / nu)) / 2;    \n    if(fit == 'lik')\n      mdl.data = (N - p) / 2 * log(sigmasq) + sum(log(seg.lengths)) / 2;\n  }\n  \n  ## if the null model\n  if(m == 0){ \n    s = solve(t(Ahat) %*% Ahat, t(Ahat) %*% Xhat);\n    mu = NULL; cov.mu = NULL;\n    sigmasq = c((t(Xhat) %*% Xhat - t(Xhat) %*% Ahat %*% s) / (N - p));\n\n    mdl.data = (N - p) / 2 * log(sigmasq);        \n  }\n  \n  #### compute bmdl\n  if(penalty == 'bmdl'){\n    m2 = sum(eta == 1 & meta == 1); N2 = sum(meta);  \n    m1 = m - m2; N1 = N - p - N2;  \n    mdl = mdl.data - lgamma(a + m1) - lgamma(b1 + N1 - m1) - lgamma(a + m2) - lgamma(b2 + N2 - m2);\n  }\n  \n  if(penalty == 'mdl')\n  \tmdl = mdl.data + log(m + 1) + (m + 1) * log(N - p);\n  \n  if(penalty == 'uniform')\n  \tmdl = mdl.data;  \n  \t\n  if(penalty == 'BIC')\n    mdl = (N - p) / 2 * log(sigmasq) + m / 2 * log(N - p);\n  \n  ## return list \"inference\"\n  return( list(mdl = c(mdl), phi = phi, sigmasq = c(sigmasq), mu = c(mu), s = c(s), cov.mu = cov.mu) );  \n}\n\n#######################\n  # start.time = proc.time();\n  # for(i in 1:1e5){\n    # #AtBA = AtA - t(UtA) %*% sweep(UtA, 1, d, FUN = \"*\");\n    # AtBA = AtA - t(UtA) %*% diag(d) %*% UtA\n  # }\n  # proc.time() - start.time;\n",
    "created" : 1504060129619.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4169311082",
    "id" : "44E3F35A",
    "lastKnownWriteTime" : 1498531760,
    "last_content_update" : 1498531760,
    "path" : "~/Dropbox/Research/2014 Joint Tmax and Tmin/Mypackage_BayesMDL/BayesMDL/R/bmdl.eta.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}