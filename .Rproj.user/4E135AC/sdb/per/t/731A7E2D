{
    "collab_server" : "",
    "contents" : "###################################################################\n######    Bayesian MDL for multiple changepoint detection   #######\n###################################################################\n\n######## Inputs #######\n## X: a vector of length N. NOT pre-processed to zero mean.\n## month: a vector of length N. Take value in {1, 2, ..., 12}.\n## meta: a vector of 0-1 indicators. \n##      Length is N, first p elemenets are always 0.\n## nu: default value 5\n## a: default value 1\n## b1: dafault value 19 (for annual data), 239 (for monthly data)\n## b2: dafault value 3 (for annual data), 47 (for monthly data)\n## type: 'annual' or 'monthly'\n\n######## Outputs ########\n## map200: 200 * (N + 3) matrix\n##         200 top models with highest posterior probability that MCMC visited\n##         along with mdl, phi, sigmasq\n## Eta: (iter / thin + 1) * (N + 3) matrix\n##         MCMC samples of change point configuration (model) eta \n\nbmdl = function(X, month = NULL, meta = NULL, iter = 1e4, thin = max(1, iter / 1e3), \n\t\t\t\ttype = 'monthly', p = 3, fit = 'marlik', penalty = 'bmdl', nu = 5, \n\t\t\t\ta = 1, b1 = 19 * (type == 'annual') + 239 * (type == 'monthly'), \n\t\t\t\tb2 = (b1 - 4) / 5, start.eta = NULL, track.time = TRUE, \n\t\t\t\tshow.summary = 10, show.month = FALSE, start.year = 1){\n\n  t.start = proc.time();\n\n  change.rate = 0;\n\n  N = length(X);  \n  \n  ## pre-process meta\n  ## for now, non-dirac meta can only be used for annual data!!!\n  if(length(meta) < N){\n  \tmeta = loc2dirac(meta, N); \n  }\n  if(length(meta) > N)\n    stop('Length of metadata cannot exceed length of time series.')\n    \n  ## output matrices\n  map200 = matrix(NA, ncol = N + p + 2, nrow = 200);\n  mcmc = matrix(NA, ncol = N + p + 2, nrow = round(iter / thin) + 1);\n  colnames(map200) = colnames(mcmc) = c(paste('eta', 1:N, sep = ''), 'mdl', paste('phi', 1:p, sep = ''), 'sigmasq');\n\n  ## initial values of eta \n  if(length(start.eta) == 0)\n    eta = rbinom(N, 1, sort(runif(2, 0, 0.05))[meta + 1]);\t## vector of change point, start value\n  if(length(start.eta) == N)\n    eta = start.eta;\n  if(length(start.eta) < N && length(start.eta) > 0)\n    eta = loc2dirac(start.eta, N);\n  if(length(start.eta) > N)\n    stop('Error in start.eta: length of changepoint configuration cannot exceed length of time series.')\n  eta[1:p] = 0;\n  \n  ## initial values\n  if(type == 'annual'){\n  \tmonth = rep(1, N);\n  \tperiod = 1;\n  }\n  if(type == 'monthly'){\n  \tif(length(month) == 0)\n  \t  month = rep(1:12, ceiling(N / 12))[1:N];\n  \tperiod = 12;\n  }\n  inference = bmdl.eta(X, month, eta, meta, p, fit, penalty, nu, a, b1, b2, period);\n  current = list(eta = eta, inference = inference, change.eta = TRUE);  \n  mcmc[1, ] = map200[1, ] = unlist(current)[1 : (N + p + 2)];  \n  \n  ## Start MCMC\n  for(it in 1:iter){\n  \t\n  \t## Use MH.flip with probablity 80%, use MH.swap with probability 20%\n    action = sample(c('flip', 'swap'), 1, prob = c(0.8, 0.2), replace = TRUE);\n    ## Metropolis-Hastings update gamma  \n    if(action == 'flip')\t\n  \t  current = bmdl.MH.flip(X, month, current, meta, p, fit, penalty, nu, a, b1, b2, period);\n    if(action == 'swap')\t\n  \t  current = bmdl.MH.swap(X, month, current, meta, p, fit, penalty, nu, a, b1, b2, period); \n\n    ## try to put the new eta to map200 if good\n    if(current$change.eta == TRUE){\n      change.rate = change.rate + 1 / iter;\n      \n      tmpk = which(c(current$inference$mdl) > map200[, N + 1]);\n      if(length(tmpk) == 0)\n        k = 0;\n      if(length(tmpk) > 0)\n  \t    k = max(tmpk);\n  \t  if(k < 200 && is.na(map200[k + 1, N + 1]))\n  \t    map200[(k + 1), ] = unlist(current)[1 : (N + p + 2)];\n  \t  if(k < 200 && sum(map200[k + 1, 1:N] != current$eta) > 0){\n  \t    if(k == 199)\n  \t      map200[200, ] = unlist(current)[1 : (N + p + 2)];\n  \t    if(k < 199){\n  \t      map200[(k + 2):200, ] = map200[(k + 1):199, ];\n  \t      map200[(k + 1), ] = unlist(current)[1 : (N + p + 2)];\n  \t    }\n  \t  }\n  \t}\n  \t\n  \t## save Markov chains    \n    if(it %% thin == 0){\n  \t  mcmc[it / thin + 1, ] = unlist(current)[1 : (N + p + 2)];\n      \n      ## show: x0% completed\n      if( (it * 10) %% iter == 0 && it != iter  && track.time == TRUE)\n        cat(paste( (it * 100) / iter), '% completed...\\n', sep = '');\n      if( it == iter  && track.time == TRUE){\n        cat(paste( (it * 100) / iter), '% completed.\\n', sep = '');\n        cat('\\n');\n      } \n    }\n  }\n\n  ## show summary: top 10 models\n  if(show.summary > 0){\n  \t\n  \tcat('accept eta: ', change.rate, '\\n');\n    cat('Top changepoint configurations: \\n');\n    if(type == 'annual'){\n      for(r in 1:show.summary)\n  \t    cat(which(map200[r, 1:N] == 1) + start.year - 1, ' mdl =', map200[r, N + 1], '\\n', sep = ' ');\n  \t}\n    if(type == 'monthly' && show.month == TRUE){\n      year = (start.year + c(rep(0, 13 - month[1]), c(matrix(rep(1 : ceiling((N - (13 - month[1])) / 12), 12), nrow = 12, byrow = TRUE))))[1 : N]; \n      yearmonth = paste(year, month.abb[month], sep = '')  \n      for(r in 1:show.summary)\n  \t    cat(yearmonth[which(map200[r, 1:N] == 1)], ' mdl =', map200[r, N + 1], '\\n', sep = ' ');\n  \t}\n    if(type == 'monthly' && show.month == FALSE){\n      for(r in 1:show.summary)\n  \t    cat(which(map200[r, 1:N] == 1), ' mdl =', map200[r, N + 1], '\\n', sep = ' ');\n  \t}\n\n  }\n  \n  input.parameters = list(X = X, month = month, meta = meta, iter = iter, thin = thin, type = type, p = p, nu = nu, a = a, b1 = b1, b2 = b2, period = period, start.year = start.year);\n  \n  ## track time\n  if(track.time == TRUE){\n    t.finish = proc.time();\n    cat('Time used (in second): \\n')\n    print(t.finish - t.start);\n    cat('\\n');\n  }\n\n  return( list(mcmc = mcmc, map200 = map200, input.parameters = input.parameters) );\n}\n\n  \n  \n  \n  \n",
    "created" : 1504060504318.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "547405250",
    "id" : "731A7E2D",
    "lastKnownWriteTime" : 1451324753,
    "last_content_update" : 1451324753,
    "path" : "~/Dropbox/Research/2014 Joint Tmax and Tmin/Mypackage_BayesMDL/BayesMDL/R/bmdl.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}